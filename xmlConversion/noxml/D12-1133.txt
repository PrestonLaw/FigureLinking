
	
		Most current dependency parsers presuppose that input words have been morphologically disambiguated using a part-of-speech tagger before parsing begins.
		We present a transition- based system for joint part-of-speech tagging and labeled dependency parsing with non- projective trees.
		Experimental evaluation on Chinese, Czech, English and German shows consistent improvements in both tagging and parsing accuracy when compared to a pipeline system, which lead to improved state-of-the- art results for all languages.
	
	
			Dependency-based syntactic parsing has been the focus of intense research efforts during the last decade, and the state of the art today is represented by globally normalized discriminative models that are induced using structured learning.
			Graph- based models parameterize the parsing problem by the structure of the dependency graph and normally use dynamic programming for inference (McDonald et al., 2005; McDonald and Pereira, 2006; Carreras, 2007; Koo and Collins, 2010; Bohnet, 2010), but other inference methods have been explored especially for non-projective parsing (Riedel and Clarke, 2006; Smith and Eisner, 2008; Martins et al., 2009; Martins et al., 2010; Koo et al., 2010).
			Transition- based models parameterize the problem by elementary parsing actions and typically use incremental beam search (Titov and Henderson, 2007; Zhang and Clark, 2008; Zhang and Clark, 2011).
			Despite notable differences in model structure, graph-based and transition-based parsers both give state-of-the- art accuracy with proper feature selection and optimization (Koo and Collins, 2010; Zhang and Nivre, 2011; Bohnet, 2011).
			It is noteworthy, however, that almost all dependency parsers presuppose that the words of an input sentence have been morphologically disambiguated using (at least) a part-of-speech tagger.
			This is in stark contrast to the best parsers based on PCFG models, such as the Brown parser (Charniak and Johnson, 2005) and the Berkeley parser (Petrov et al., 2006; Petrov and Klein, 2007), which not only can perform their own part-of-speech tagging but normally give better parsing accuracy when they are allowed to do so.
			This suggests that joint models for tagging and parsing might improve accuracy also in the case of dependency parsing.
			It has been argued that joint morphological and syntactic disambiguation is especially important for richly inflected languages, where there is considerable interaction between morphology and syntax such that neither can be fully disambiguated without considering the other.
			Thus, Lee et al.
			(2011) show that a discriminative model for joint morphological disambiguation and dependency parsing outperforms a pipeline model in experiments on Latin, Ancient Greek, Czech and Hungarian.
			However, Li et al.
			(2011) and Hatori et al.
			(2011) report improvements with a joint model also for Chinese, which is not a richly inflected language but is nevertheless rich in part-of-speech ambiguities.
			In this paper, we present a transition-based model for joint part-of-speech tagging and labeled dependency parsing with non-projective trees.
			Exper 1455 Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, pages 1455–1465, Jeju Island, Korea, 12–14 July 2012.
			Qc 2012 Association for Computational Linguistics iments show that joint modeling improves both tagging and parsing accuracy, leading to state-of-the-art accuracy for richly inflected languages like Czech and German as well as more configurational languages like Chinese and English.
			To our knowledge, this is the first joint system that performs labeled dependency parsing.
			It is also the first joint system that achieves state-of-the-art accuracy for non-projective dependency parsing.
	
	
			Transition-based dependency parsing was pioneered by Yamada and Matsumoto (2003) and Nivre et al.
			(2004), who used classifiers trained to predict individual actions of a deterministic shift-reduce parser.
			Recent research has shown that better accuracy can be achieved by using beam search and optimizing models on the entire sequence of decisions needed to parse a sentence instead of single actions (Zhang and Clark, 2008; Huang and Sagae, 2010; Zhang and Clark, 2011; Zhang and Nivre, 2011; Bohnet, 2011).
			In addition, a number of different transition systems have been proposed, in particular for dealing with non-projective dependencies, which were beyond the scope of early systems (Attardi, 2006; Nivre, 2007; Nivre, 2009; Titov et al., 2009).
			In this section, we start by defining a transition system for joint tagging and parsing based on the non-projective transition system proposed in Nivre (2009).
			We then show how to perform beam search and structured online learning with this model, and conclude by discussing feature representations.
			2.1 Transition System.
			Given a set P of part-of-speech tags and a set D of dependency labels, a tagged dependency tree for artificial root node 0.
			The set A of arcs is a set of pairs (i, j), where i is the head node and j is the dependent node.
			The functions π and δ assign a unique part-of-speech label to each node/word and a unique dependency label to each arc, respectively.
			This notion of dependency tree differs from the standard definition only by including part-of-speech labels as well as dependency labels (Ku¨ bler et al., 2009).
			Following Nivre (2008), we define a transition system for dependency parsing as a quadruple S = (C, T , cs, Ct), where 1.
			C is a set of configurations, 2.
			T is a set of transitions, each of which is a (partial) function t : C → C , 3.
			cs is an initialization function, mapping a sentence x to a configuration c ∈ C , 4.
			Ct ⊆ C is a set of terminal configurations..
			A transition sequence for a sentence x in S is a sequence of configuration-transition pairs C0,m = [(c0, t0), (c1, t1), . . .
			, (cm, tm)] where c0 = cs(x), tm(cm) ∈ Ct and ti(ci) = ci+1 (0 ≤ i < m).1 In this paper, we take the set C of configurations to be the set of all 5tuples c = (Σ, B, A, π, δ) such that Σ (the stack) and B (the buffer) are disjoint sublists of the nodes Vx of some sentence x, A is a set of dependency arcs over Vx, and π and δ are labeling functions as defined above.
			We take the initial configuration for a sentence x = w1, . . .
			, wn to be cs(x) = ([0], [1, . . .
			, n], { }, ⊥, ⊥), where ⊥ is the function that is undefined for all arguments, and we take the set Ct of terminal configurations to be the set of all configurations of the form c = ([0], [ ], A, π, δ) (for any A, π and δ).
			The tagged dependency tree defined for x by c = (Σ, B, A, π, δ) a sentence x = w1, . . .
			, wn is a directed tree T = (Vx, A) with labeling functions π and δ such that: is the tree (Vx , A) with labeling functions π and δ, 1.
			Vx = {0, 1, . . .
			, n} is a set of nodes,.
			2.
			A ⊆ Vx × Vx is a set of arcs, 3.
			π : Vx → P is a labeling function for nodes, 4.
			δ : A → D is a labeling function for arcs, 5.
			0 is the root of the tree.
			The set Vx of nodes is the set of positive integers up to and including n, each corresponding to the linear position of a word in the sentence, plus an extra which we write TREE(x, c).
			The set T of transitions is shown in Figure 1.
			The LEFT-ARCd and RIGHT-ARCd transitions both add an arc (with dependency label d) between the two nodes on top of the stack and replaces these nodes by the head node of the new arc (which is the rightmost node for LEFT-ARCd and the leftmost node for RIGHT-ARCd).
			The SHIFTp transition extracts the 1 This definition of transition sequence differs from that of.
			Nivre (2008) but is equivalent and suits our presentation better.
			T r a n s it i o n C o n d i t i o n L E F T A R C d R I G H T A R C d S H I F T p S W A P ( [ σ | i , j ] , B , A , π , δ ) ⇒ ( [ σ | j ] , B , A ∪ { ( j , i ) } , π , δ [ ( j , i ) → d ] ) ( [ σ | i , j ] , B , A , π , δ ) ⇒ ( [ σ | i ] , B , A ∪ { ( i , j ) } , π , δ [ ( i , j ) → d ] ) ( σ , [ i | β ] , A , π , δ ) ⇒ ( [ σ | i ] , β , A , π [ i → p ] , δ ) ( [ σ | i , j ] , β , A , π , δ ) ⇒ ( [ σ | j ] , [ i | β ] , A , π , δ ) i / = 0 0 < i < j Figure 1: Transitions for joint tagging and dependency parsing extending the system of Nivre (2009).
			The stack Σ is represented as a list with its head to the right (and tail σ) and the buffer B as a list with its head to the left (and tail β).
			The notation f [a → b] is used to denote the function that is exactly like f except that it maps a to b. first node in the buffer, pushes it onto the stack and PARSE(x, w, b1, b2) lab els it wit h the part-of spe ech tag p. Th e SW AP 1 h0.
			c ← cs( x) tran sitio n extr act s the sec ond top mo st nod e fro m the 2 h0.
			s ← 0.0 sta ck and mo ves it bac k to the buff er, sub ject to the 3 h0.
			f ← {0.
			0}d im( w) con diti on that the two top nod es on the sta ck are still 4 BE AM ← [h0 ] in the ord er giv en by the se nte nc e. 5 wh ile ∃h ∈ BE AM : h.c /∈ Ct E x c e p t f o r t h e a d d it i o n o f a t a g p a r a m e t e r p t o 6 T M P ← [ ] the SHI FT tra nsit ion, thi s is equ ival ent to the sys 7 f o r e a c h h ∈ B E A M tem des crib ed in Niv re (20 09) , whi ch tha nks to the 8 f o r e a c h t ∈ T : P E R M I S S I B L E ( h . c , t ) SW AP tra nsit ion can han dle arbi trar y non pro ject ive 9 h . f ← h . f + f ( h . c , t ) tree s. The sou ndn ess and co mpl ete nes s res ults giv 1 0 h . s ← h . s + f ( h . c , t ) · w en in that pap er trivi ally car ry ove r to the ne w sys 1 1 h . c ← t ( h . c ) tem . Th e onl y thin g to not e is that , bef ore a ter mi nal 1 2 T M P ← I N S E R T ( h , T M P ) configuratio n can be reached, every word has to be 13 BEAM ← PRUNE(TMP, b1, b2) pus hed ont o the sta ck in a SHI FTp tra nsit ion, whi ch 1 4 h ← TO P( BE AM ) ens ure s that eve ry nod e/w ord in the out put tree will 1 5 y ← TR EE( x, h.c ) be tag ge d. 1 6 ret ur n y 2.2 Inference and Learning.
			While early transition-based parsers generally used greedy best-first inference and locally trained classifiers, recent work has shown that higher accuracy can be obtained using beam search and global structure learning to mitigate error propagation.
			In particular, it seems that the globally learned models can exploit a much richer feature space than locally trained classifiers, as shown by Zhang and Nivre (2011).
			Since joint tagging and parsing increases the size of the search space and is likely to require novel features, we use beam search in combination with structured perceptron learning.
			The beam search algorithm used to derive the best parse y for a sentence x is outlined in Figure 2.
			In addition to the sentence x, it takes as input a weight vector w corresponding to a linear model for scoring transitions out of configurations and two prun Figure 2: Beam search algorithm for joint tagging and dependency parsing of input sentence x with weight vector w and beam parameters b1 and b2 . The symbols h.c, h.s and h.f denote, respectively, the configuration, score and feature representation of a hypothesis h; h.c.A denotes the arc set of h.c. ing parameters b1 and b2.
			A parse hypothesis h is represented by a configuration h.c, a score h.s and a feature vector h.f for the transition sequence up to h.c. Hypotheses are stored in the list BEAM, which is sorted by descending scores and initialized to hold the hypothesis h0 corresponding to the initial configuration cs(x) with score 0.0 and all features set to 0.0 (lines 1–4).
			In the main loop (lines 5–13), a set of new hypotheses is derived and stored in the list TMP, which is finally pruned and assigned as the new value of BEAM.
			The main loop terminates when all hypotheses in BEAM contain terminal configurations, and the dependency tree extracted from the top scoring hypothesis is returned (lines 14–16).
			The set of new hypotheses is created in two nested loops (lines 7–12), where every hypothesis h in BEAM is updated using every permissible transition t for the configuration h.c. The feature representation of the new hypothesis is obtained by adding the feature vector f(t, h.c) for the current configuration- transition pair to the feature vector of the old hypothesis (line 9).
			Similarly, the score of the new ly dependency labels or tags.
			Thus, in the experiments later on, we will typically constrain the parser so that SHIFTp is permissible only if p is one of the k best part-of-speech tags with a score no more than α below the score of the 1-best tag, as determined by a preprocessing tagger.
			We also filter out instances of LEFT-ARCd and RIGHT-ARCd, where d does not occur in the training data for the predicted part-of- speech tag combination of the head and dependent.
			This procedure leads to a significant speed up.
			In order to learn a weight vector w from a training hypothesis is the sum of the score f(t, h.c) · w of set {(xj , yj )}Tof sentences with their tagged dethe current configuration-transition pair and the s core of the old hypothesis (line 10).
			The feature representation/score of a complete parse y for x with transition sequence C0,m is thus the sum of the feature representations/scores of the configuration- transition pairs in C0,m: pendency trees, we use a variant of the structured perceptron, introduced by Collins (2002), which makes N iterations over the training data and updates the weight vector for every sentence xj where the highest scoring parse y∗ is different from yj .More precisely, we use the passive-aggressive up date of Crammer et al.
			(2006): f(x, y) = ) (c,t)∈C0,m s(x, y) = ) (c,t)∈C0,m f(c, t) f(c, t) · w where wi+1 = wi + τ (f(xj , yj ) − f(xj , y∗)) f(xj , yj ) − f(xj , y∗) Finally, the configuration of the new hypothesis is obtained by evaluating t(h.c) (line 11).
			The new hypothesis is then inserted into TMP in score-sorted order (line 12).
			The pruning parameters b1 and b2 determine the number of hypotheses allowed in the beam and at the same time control the tradeoff between syntactic and morphological ambiguity.
			First, we extract the b1 highest scoring hypotheses with distinct dependency trees.
			Then we extract the b2 highest scoring remaining hypotheses, which will typically be tagging variants of dependency trees that are already in the beam.
			In this way, we prevent the beam from getting filled up with too many tagging variants of the same dependency tree, which was found to be harmful in preliminary experiments.
			One final thing to note about the inference algorithm is that the notion of permissibility for a transition t out of a configuration c can be used to capture not only formal constraints on transitions – such as the fact that it is impossible to perform a SHIFTp transition with an empty buffer or illegal to perform a LEFT-ARCd transition with the special root node on top of the stack – but also to filter out unlike τ = ||f(xj , yj ) − f(xj , y∗)||2 We also use the early update strategy found beneficial for parsing in several previous studies (Collins and Roark, 2004; Zhang and Clark, 2008; Huang and Sagae, 2010), which means that, during learning, we terminate the beam search as soon as the hypothesis corresponding to the gold parse yj falls out of the beam and update with respect to the partial transition sequence constructed up to that point.
			Finally, we use the standard technique of averaging over all weight vectors, as originally proposed by Collins (2002).
			2.3 Feature Representations.
			As already noted, the feature representation f(x, y) of an input sentence x with parse y decomposes into feature representations f(c, t) for the transitions t(c) needed to derive y from cs(x).
			Features may refer to any aspect of a configuration, as encoded in the stack Σ, the buffer B, the arc set A and the labelings π and δ.
			In addition, we assume that each word w in the input is assigned up to k candidate part-of-speech tags πi(w) with corresponding scores s(πi(w)).
			Fea ture s inv olvi ng wor d pref ixe s and suff ixe s πi (B0 )p2 (B0 ), πi (B0 )s2 (B0 ), πi (B0 )p1 (B0 )p1 (Σ0 ) πi (Σ0 )p1 (Σ0 )p1 (Σ1 ), πi (Σ0 )s1 (Σ0 )s1 (Σ0 ) πi (Σ0 )p2 (Σ0 )s3 (Σ1 ),πi (Σ0 )s3 (Σ0 )p2 (Σ1 ) πi (Σ0 )w( B0 )s1 (Σ0 ), πi (Σ0 )w( B0 )s2 (Σ0 ) Fea ture s inv olvi ng tag sco re diff ere nce s and ran ks πi (B0 )[s( π1 (B0 )) − s(π i (B0 ))] πi (B0 )πi (Σ0 )[s( π1 (B0 )) − s(π i (B0 ))] i πi (B0 )[s( π1 (B0 )) − s(π i (B0 ))]π (Σ0 ) w( B0 )[s( π1 (B0 )) − s(π i (B0 ))]π (Σ0 ) Figure 3: Specialized feature templates for tagging.
			We use Σi and Bi to denote the ith token in the stack Σ and buffer B, respectively, with indexing starting at 0, and we use the following functors to extract properties of a token: πi () = ith best tag; s(πi ()) = score of ith best tag; π() = finally predicted tag; w() = word form; pi () = word prefix of i characters; si () = word suffix of i characters.
			Score differences are binned in discrete steps of 0.05.
			The bulk of features used in our system are taken from Zhang and Nivre (2011), although with two important differences.
			First of all, like Hatori et al.
			(2011), we have omitted all features that presuppose an arc-eager parsing order, since our transition system defines an arc-standard order.
			Secondly, any feature that refers to the part-of-speech tag of a word w in the buffer B will in our system refer to the top- scoring tag π1(w), rather than the finally predicted tag.
			By contrast, for a word in the stack Σ, part-of- speech features refer to the tag π(w) chosen when shifting w onto the stack (which may or may not be the same as π1(w)).
			In addition to the standard features for transition- based dependency parsing, we have added features specifically to improve the tagging step in the joint model.
			The templates for these features, which are specified in Figure 3, all involve the ith best tag assigned to the first word of the buffer B (the next word to be shifted in a SHIFTp transition) in combination with neighboring words, word prefixes, word suffixes, score differences and tag rank.
			limited to certain first- and second-order factors, we use features over second- and third-order factors as found in the parsers of Bohnet and Kuhn (2012).
			These features are scored as soon as the factors are completed, using a technique that is similar to what Hatori et al.
			(2011) call delayed features, although they use it for part-of-speech tags in the lookahead while we use it for subgraphs of the dependency tree.
			Cluster features, finally, are features over word clusters, as first used by Koo et al.
			(2008), which replace part-of-speech tag features.2 We use a hash kernel to map features to weights.
			It has been observed that most of the computing time in feature-rich parsers is spent retrieving the index of each feature in the weight vector (Bohnet, 2010).
			This is usually done via a hash table, but significant speedups can be achieved by using a hash kernel, which simply replaces table lookup by a hash function (Bloom, 1970; Shi et al., 2009; Bohnet, 2010).
			The price to pay for these speedups is that there may be collisions, so that different features are mapped to the same index, but this is often compensated by the fact that the lower time and memory requirements of the hash kernel enables the use of negative features, that is, features that are never seen in the training set but occur in erroneous hypotheses at training time and can therefore be helpful also at inference time.
			As a result, the hash kernel often improves accuracy as well as efficiency compared to traditional techniques that only make use of features that occur in gold standard parses (Bohnet, 2010).
	
	
			We have evaluated the model for joint tagging and dependency parsing on four typologically diverse languages: Chinese, Czech, English, and German.
			3.1 Setup.
			Most of the experiments use the CoNLL 2009 data sets with the training, development and test s Finally, in some experiments, we make use of two plit used in the Shared Task (Hajicˇ et al., 2009), additional feature sets, which we call graph features (G) and cluster features (C), respectively.
			Graph features are defined over the factors of a graph-based dependency parser, which was shown to improve the accuracy of a transition-based parser by Zhang and Clark (2008).
			However, while their features were but for better comparison with previous work we also report results for the standard benchmark data sets for Chinese and English.
			For Chinese, this is the Penn Chinese Treebank 5.1 (CTB5), converted 2 For replicability, a complete description of all features can be found at http://stp.lingfil.uu.se/∼nivre/exp/emnlp12.html.
			Par ser k α C h i n e s e TLA S LAS UAS POS C z e c h TLA S LAS UAS POS E n g l i s h TLA S LAS UAS POS G e r m a n TLA S LAS UAS POS 1 0.0 73.
			85 76.
			12 80.
			01 92.
			78 82.
			36 82.
			65 88.
			03 93.
			26 85.
			82 87.
			17 90.
			41 97.
			32 85.
			08 86.
			60 89.
			17 97.
			24 2 0.1 74.
			39 76.
			52 80.
			41 93.
			37 82.
			74 83.
			01 88.
			34 99.
			39 86.
			43 87.
			79 91.
			02 97.
			49 86.
			12 87.
			22 89.
			69 97.
			85 3 0.1 3 0.2 3 0.3 3 0.4 74.
			47 76.
			63 80.
			50 93.
			38 74.
			35 76.
			48 80.
			38 93.
			43 74.
			18 76.
			33 80.
			28 93.
			48 82.
			76 82.
			97 88.
			33 99.
			40 82.
			85 83.
			11 88.
			44 99.
			32 82.
			78 83.
			05 88.
			38 99.
			33 86.
			40 87.
			78 90.
			99 97.
			43 86.
			35 87.
			79 91.
			01 97.
			52 85.
			94 87.
			57 90.
			87 96.
			97 86.
			03 87.
			27 89.
			60 97.
			74 86.
			24 87.
			37 89.
			72 97.
			90 86.
			35 87.
			46 89.
			86 97.
			90 86.
			14 87.
			23 89.
			66 97.
			79 Table 1: Accuracy scores for the CoNLL 2009 shared task development sets as a function of the number of tags k and the score threshold α.
			Beam parameters fixed at b1 = 40, b2 = 4.
			with the head-finding rules and conversion tools of Zhang and Clark (2008), and with the same split as in Zhang and Clark (2008) and Li et al.
			(2011).3 For English, this is the WSJ section of the Penn Tree- bank, converted with the head-finding rules of Yamada and Matsumoto (2003) and the labeling rules of Nivre (2006).4 In order to assign k-best part-of-speech tags and scores to words in the training set, we used a per- ceptron tagger with 10-fold jackknifing.
			The same type of tagger was trained on the entire training set in order to supply tags for the development and test sets.
			The feature set of the tagger was optimized for English and German and provides state-of-the- art accuracy for these two languages.
			The 1-best tagging accuracy for section 23 of the Penn Tree- bank is 97.28, which is on a par with Toutanova et al.
			(2003).
			For German, we obtain a tagging accuracy of 97.24, which is close to the 97.39 achieved by the RFTagger (Schmid and Laws, 2008), which to our knowledge is the best tagger for German.5 The results are not directly comparable to the RFTagger as it was evaluated on a different part of the Tiger Treebank and trained on a larger part of the Tree- bank.
			We could not use the larger training set as it contains the test set of the CoNLL 2009 data that we use to evaluate the joint model.
			For Czech, the 1- best tagging accuracy is 99.11 and for Chinese 92.65 on the CoNLL 2009 test set.
			We trained parsers with 25 iterations and report 3 Training: 001–815, 1001–1136.
			Development: 886–931,.
			1148–1151.
			Test: 816–885, 1137–1147.
			5 The RFTagger can take advantage of an additional lexicon and then reaches 97.97.
			The lexicon supplies entries for addi results for the model obtained after the last iteration.
			For cluster features, available only for English and German, we used standard Brown clusters based on the English and German Gigaword Corpus.
			We restricted the vocabulary to words that occur at least 10 times, used 800 clusters, and took cluster prefixes of length 6 to define features.
			We report the following evaluation metrics: part- of-speech accuracy (POS), unlabeled attachment score (UAS), labeled attachment score (LAS), and tagged labeled attachment score (TLAS).
			TLAS is a new metric defined as the percentage of words that are assigned the correct part-of-speech tag, the correct head and the correct dependency label.
			In line with previous work, punctuation is included in the evaluation for the CoNLL data sets but excluded for the two benchmark data sets.
			3.2 Results.
			Table 1 presents results on the development sets of the CoNLL 2009 shared task with varying values of the two tag parameters k (number of candidates) and α (maximum score difference to 1-best tag) and beam parameters fixed at b1 = 40 and b2 = 4.
			We use the combined TLAS score on the development set to select the optimal settings for each language.
			For Chinese, we obtain the best result with 3 tags and a threshold of 0.1.6 Compared to the baseline, we observe a POS improvement of 0.60 and a LAS improvement of 0.51.
			For Czech, we get the best T- LAS with k = 3 and α = 0.2, where POS improves by 0.06 and LAS by 0.46.
			For English, the best setting is k = 2 and α = 0.1 with a POS improvement of 0.17 and a LAS improvement of 0.62.
			For German, finally, we see the greatest improvement with k = 3 tional words that are not found in the training corpus and additional tags for words that do occur in the training data (Schmid and Laws, 2008).
			6 While tagging accuracy (POS) increases with larger values.
			of α, TLAS decreases because of a drop in LAS.
			Par ser C h i n e s e TLA S LAS UAS POS C z e c h TLA S LAS UAS POS E n g l i s h TLA S LAS UAS POS G e r m a n TLA S LAS UAS POS Ges mun do et al.
			(20 09) Boh net (20 10) 7 6 . 1 1 9 2 . 3 7 7 6 . 9 9 9 2 . 3 7 8 0 . 3 8 9 9 . 3 3 8 0 . 9 6 9 9 . 3 3 8 8 . 7 9 9 7 . 4 8 9 0 . 3 3 9 7 . 4 8 8 7 . 2 8 9 5 . 4 6 8 8 . 0 6 9 5 . 4 6 Base line (k = 1), b1 = 40 Best dev setti ng, b1 = 40 73.6 6 76.5 5 80.7 7 92.
			65 74.7 2 77.0 0 81.1 8 93.
			06 82.0 7 82.4 4 87.8 3 99.
			11 82.5 6 82.7 0 88.0 7 99.
			32 87.8 9 89.1 9 91.7 4 97.
			57 88.2 6 89.5 4 92.0 6 97.
			77 86.1 1 87.7 8 90.1 3 97.
			24 86.9 1 88.2 3 90.4 3 97.
			63 Addi ng G, b1 = 80 Addi ng G+C , b1 = 80 75.8 4 78.5 1 82.5 2 93.
			19 83.3 8 83.7 3 88.8 2 99.
			33 88.9 2 90.2 0 92.6 0 97.
			77 89.2 2 90.6 0 92.8 7 97.
			84 87.8 6 89.0 5 91.1 6 97.
			78 88.3 1 89.3 8 91.3 7 98.
			05 Table 2: Accuracy scores for the CoNLL 2009 shared task test sets.
			Rows 1–2: Top performing systems in the shared CoNLL Shared Task 2009; Gesmundo et al.
			(2009) was placed first in the shared task; for Bohnet (2010), we include the updated scores later reported due to some improvements of the parser.
			Rows 3–4: Baseline (k = 1) and best settings for k and α on development set.
			Rows 5–6: Wider beam (b1 = 80) and added graph features (G) and cluster features (C).
			Second beam parameter b2 fixed at 4 in all cases.
			and α = 0.3, where POS improves by 0.66 and LAS by 0.86.
			Table 2 shows the results on the CoNLL 2009 test sets.
			For all languages except English, we obtain state-of-the-art results already with b1 = 40 (row 4), and for all languages both tagging and parsing accuracy improve compared to the baseline (row 3).
			The improvement in TLAS is statistically significant with p < 0.01 for all languages (paired t-test).
			Row 5 shows the scores with a beam of 80 and the additional graph features.
			Here the LAS scores for Chinese, Czech and German are higher than the best results on the CoNLL 2009 data sets, and the score for English is highly competitive.
			For Chinese, we achieve 78.51 LAS, which is 1.5 percentage points higher than the reference score, while the POS score is 0.54 higher than our baseline.
			For Czech, we get 83.73 LAS, which is by far the highest score reported for this data set, together with state-of-the-art POS accuracy.
			For German, we obtain 89.05 LAS and 97.78 POS, which in both cases is substantially better than in the CoNLL shared task.
			We believe it is also the highest POS accuracy ever reported for a tagger/parser trained only on the Tiger Treebank.
			Row 6, finally, presents results with added cluster features for English and German, which results in additional improvements in all metrics.
			Table 3 gives the results for the Penn Treebank converted with the head-finding rules of Yamada and Matsumoto (2003) and the labeling rules of Nivre (2006).
			We use k = 3 and α = 0.4, which gave the best results on the development set.
			The UAS improves by 0.24 when we do joint tagging and parsing.
			The POS accuracy improves slightly by 0.12 Par ser TLA S UA S LA S PO S Mc Don ald et al.
			(20 05) McD onal d and Pere ira (200 6) Zha ng and Clar k (20 08) Hua ng and Sag ae (20 10) K o o a n d C o l l i n s ( 2 0 1 0 ) Z h a n g a n d N i v r e ( 2 0 1 1 ) M a r t i n s e t a l .
			( 2 0 1 0 ) 90.
			9 91.
			5 92.
			1 92.
			1 93.0 4 92.
			9 93.2 6 Koo et al.
			(200 8) † Carr eras et al.
			(200 8) † Suz uki et al.
			(20 09) † 93.1 6 93.
			5 93.7 9 Bas elin e (k = 1), b1 = 40 Best dev setti ng, b1 = 40 89.
			42 89.
			75 92.7 9 93.0 3 91.7 1 91.9 2 97.2 8 97.4 0 Add ing G, b1 = 40 Add ing G+ C, b1 = 80 † 90.
			12 90.
			41 93.3 8 93.6 7 92.4 4 92.6 8 97.3 3 97.4 2 Table 3: Accuracy scores for WSJPTB converted with head rules of Yamada and Matsumoto (2003) and labeling rules of Nivre (2006).
			Best dev setting: k = 3, α = 0.4.
			Results marked with † use additional information sources and are not directly comparable to the others.
			but to a lower degree than for the English CoNL- L data where we observed an improvement of 0.20.
			Nonetheless, the improvement in the joint TLAS score is statistically significant at p < 0.01 (paired t-test).
			Our joint tagger and dependency parser with graph features gives very competitive unlabeled dependency scores for English with 93.38 UAS.
			To the best of our knowledge, this is the highest score reported for a (transition-based) dependency parser that does not use additional information sources.
			By adding cluster features and widening the beam to b1 = 80, we achieve 93.67 UAS.
			We also obtain a POS accuracy of 97.42, which is on a par with the best results obtained using semi-supervised taggers Par ser TL AS UA S LA S PO S MS TP ars er1 MS TP ars er2 Li et al.
			(20 11) 3rd ord er Li et al.
			(20 11) 2nd ord er Hat ori et al.
			(20 11) HS Hat ori et al.
			(20 11) ZN 75.
			56 77.
			73 80.
			60 80.
			55 79.
			60 81.
			20 93.
			51 93.
			51 92.
			80 93.
			08 94.
			01 93.
			94 Bas elin e (k = 1), b1 = 40 Bes t dev setti ng, b1 = 40 61.
			95 62.
			54 80.
			33 80.
			59 76.
			79 77.
			06 92.
			81 93.
			11 Add ing G, b1 = 80 63.
			20 81.
			42 77.
			91 93.
			24 Table 4: Accuracy scores for Penn Chinese Treebank converted with the head rules of Zhang and Clark (2008).
			Best dev setting: k = 3, α = 0.1.
			MSTParser results from Li et al.
			(2011).
			UAS scores from Li et al.
			(2011) and Ha- tori et al.
			(2011) recalculated from the separate accuracy scores for root words and non-root words reported in the original papers.
			(Søgaard, 2011).
			Table 4 shows the results for the Chinese Penn Treebank CTB 5.1 together with related work.
			In experiments with the development set, we could confirm the results from the Chinese CoNLL data set and obtained the best results with the same settings (k = 3, α = 0.1).
			With b1 = 40, UAS improves by 0.25 and POS by 0.30, and the TLAS improvement is again highly significant (p < 0.01, paired t-test).
			We get the highest UAS, 81.42, with a beam of 80 and added graph features, in which case POS accuracy increases from 92.81 to 93.24.
			Since our tagger was not optimized for Chinese, we have lower baseline results for the tagger than both Li et al.
			(2011) and Hatori et al.
			(2011) but still manage to achieve the highest reported UAS.
			The speed of the joint tagger and dependency parser is quite reasonable with about 0.4 seconds per sentence on the WSJPTB test set, given that we perform tagging and labeled parsing with a beam of 80 while incorporating the features of a third-order graph-based model.
			Experiments were performed on a computer with an Intel i73960X CPU (3.3 GHz and 6 cores).
			These performance values are preliminary since we are still working on the speedup of the parser.
			3.3 Analysis.
			In order to better understand the benefits of the joint model, we performed an error analysis for German Table 5: Selected entries from the confusion matrix for parts of speech in German with F-scores for the left-hand- side category.
			ADJ* (ADJD or ADJA) = adjective; ADV = adverb; ART = determiner; APPR = preposition; NE = proper noun; NN = common noun; PRELS = relative pronoun; VVFIN = finite verb; VVINF = non-finite verb; VAFIN = finite auxiliary verb; VAINF = non-finite auxiliary verb; VVPP = participle; XY = not a word.
			We use α* to denote the set of categories with α as a prefix.
			and English, where we compared the baseline and the joint model with respect to F-scores for individual part-of-speech categories and dependency labels.
			For the part-of-speech categories, we found an improvement across the board for both languages, with no category having a significant decrease in F-score, but we also found some interesting patterns for categories that improved more than the average.
			Table 5 shows selected entries from the confusion matrix for German, where we see substantial improvements for finite and non-finite verbs, which are often morphologically ambiguous but which can be disambiguated using syntactic context.
			We also see improved accuracies for common and proper nouns, which are both capitalized in standard German orthography and therefore often mistagged, and for relative pronouns, which are less often confused for determiners in the joint model.
			Table 6 gives a similar snapshot for English, and we again see improvements for verb categories that are often morphologically ambiguous, such as past participles, which can be confused for past tense verbs, and present tense verbs in third person singular, which can be confused for nouns.
			We also see some improvement for the singular noun catego C o n f u s i o n B a s e l i n e Freq F scor e J o i n t Freq F scor e VB N → VB D VB N → JJ|V B|V BP| NN 4 0 90.5 1 3 1 9 91.5 1 8 VB Z → NN| NN S VB Z → POS |JJ| RB 1 9 97.8 6 1 3 98.3 6 NN → VB G|V B|V BN| VB D NN → JJ|J JR NN → NN *|R B|I N|D T 7 2 7 9 96.8 5 8 5 8 6 9 97.2 5 7 RB → IN RB → JJ*| RP| NN *|R BR| UH 12 6 92.4 8 6 9 3 92.9 8 9 Table 6: Selected entries from the confusion matrix for parts of speech in English with F-scores for the left-hand- side category.
			DT = determiner; IN = preposition or subordinating conjunction; JJ = adjective; JJR = comparative adjective; NN = singular or mass noun; NNS = plural noun; POS = possessive clitic; RB = adverb; RBR = comparative adverb; RP = particle; UH = interjection; VB = base form verb; VBD = past tense verb; VBG = gerund or present participle; VBN = past participle; VBP = present tense verb, not 3rd person singular; VBZ = present tense verb, 3rd person singular.
			We use α* to denote the set of categories with α as a prefix.
			ry and for adverbs, which are less often confused for prepositions or subordinating conjunctions thanks to the syntactic information in the joint model.
			For dependency labels, it is hard to extract any striking patterns and it seems that we mainly see an improvement in overall parsing accuracy thanks to less severe tagging errors.
			However, it is worth observing that, for both English and German, we see significant F-score improvements for the core gram matical functions subject (91.3 → 92.1 for German, 95.6 → 96.1 for English) and object (86.9 → 87.9 for German, 90.2 → 91.9 for English).
	
	
			Our work is most closely related to Lee et al.
			(2011), Li et al.
			(2011) and Hatori et al.
			(2011), who all present discriminative models for joint tagging and dependency parsing.
			However, all three models only perform unlabeled parsing, while our model incorporates dependency labels into the parsing process.
			Whereas Lee et al.
			(2011) and Li et al.
			(2011) take a graph-based approach to dependency parsing, Ha- tori et al.
			(2011) use a transition-based model similar to ours but limited to projective dependency trees.
			Both Li et al.
			(2011) and Hatori et al.
			(2011) only evaluate their model on Chinese, and of these only Hatori et al.
			(2011) report consistent improvements in both tagging and parsing accuracy.
			Like our system, the parser of Lee et al.
			(2011) can handle non- projective trees and experimental results are presented for four languages, but their graph-based model is relatively simple and the baselines therefore well below the state of the art.
			We are thus the first to show consistent improvements in both tagging and (labeled) parsing accuracy across typologically diverse languages at the state-of-the-art level.
			Moreover, the capacity to handle non-projective dependencies, which is crucial to attain good performance on Czech and German, does not seem to hurt performance on English and Chinese, where the benchmark sets contain only projective trees.
			The use of beam search in transition-based dependency parsing in order to mitigate the problem of error propagation was first proposed by Johansson and Nugues (2006), although they still used a locally trained model.
			Globally normalized models were first explored by Titov and Henderson (2007), who were also the first to use a parameterized SHIFT transition like the one found in both Hatori et al.
			(2011) and our own work, although Titov and Henderson (2007) used it to define a generative model by pa- rameterizing the SHIFT transition by an input word.
			Zhang and Clark (2008) was the first to combine beam search with a globally normalized discrimi- native model, using structured perceptron learning and the early update strategy of Collins and Roark (2004), and also explored the addition of graph- based features to a transition-based parser.
			This approach was further pursued in Zhang and Clark (2011) and was used by Zhang and Nivre (2011) to achieve state-of-the-art results in dependency parsing for both Chinese and English through the addition of rich non-local features.
			Huang and Sagae (2010) combined structured perceptron learning and beam search with the use of a graph-structured stack to allow ambiguity packing in the beam, a technique that was reused by Hatori et al.
			(2011).
			Finally, as noted in the introduction, although joint tagging and parsing is rare in dependency parsing, most state-of-the-art parsers based on PCFG models naturally incorporate part-of-speech tagging and usually achieve better parsing accuracy (albeit not always tagging accuracy) with a joint model than with a pipeline approach (Collins, 1997; Charniak, 2000; Charniak and Johnson, 2005; Petrov et al., 2006).
			Models that in addition incorporate morphological analysis and segmentation have been explored by Tsarfaty (2006), Cohen and Smith (2007), and Goldberg and Tsarfaty (2008) with special reference to Hebrew parsing.
	
	
			We have presented the first system for joint part- of-speech tagging and labeled dependency parsing with non-projective dependency trees.
			Evaluation on four languages shows consistent improvements in both tagging and parsing accuracy over a pipeline system with state-of-the-art results across the board.
			The error analysis reveals improvements in tagging accuracy for syntactically central categories, mainly verbs, with improvement in syntactic accuracy for core grammatical functions as a result.
			In future work we intend to explore joint models that incorporate not only basic part-of-speech tags but also more fine-grained morphological features.
	
