
	
	
			Computer scientists and linguists now largely agree that representing discourse structure as a hierarchical relational structure over discourse units linked by discourse relations is appropriate to account for a variety of interpretative tasks.
			There is also some agreement over the taxonomy of discourse relations —almost all current theories include expressions that refer to relations like Elaboration, Explanation, Result, Narration, Contrast, Attribution.
			Sanders, Spooren, and Noord- man 1992; Bateman and Rondhuis 1997 discuss correspondences between different taxonomies.
			Different theories, however, assume different sets of constraints that govern these representations; some advocate trees: RST Mann and Thompson 1987, DLTAG Webber et al. 1999; others, graphs of different sorts: SDRT Asher and Lascarides 2003, Graphbank Wolf and Gibson 2005.
			Consider: (1) [“he was a very aggressive firefighter.]C1 [he loved the work he was in,”]C2 [said acting fire chief Lary Garcia.]C3 . [”He couldn’t be bested in terms of his willingness and his ability to do something to help you survive.”]C4 (from Egg and Redeker 2010) Using RST, Egg and Redeker 2010 provide the tree annotated with nuclearity features for this example (given by the linear encoding in (s1 )), while SDRT provides ∗This research was supported by ERC grant 269427.
			Attr(π, C3 ) ∧ π : Elab(C1 , π1 ) ∧ π1 : Cont(C2 , C4 ) (s2 ) Elab1 (C1 , C2 ) ∧ Attr(C1 , C3 ) ∧ Elab(C1 , C4 ) (s3 ) Several corpora now exist annotated with such structures: RSTTB Carlson, Marcu, and Okurowski 2002, Discor Baldridge, Asher, and Hunter 2007, Graph- Bank1 . But how exactly do these annotations compare?
			In the illustrative example chosen and for the relation types they agree on (Elaboration and Attribution), different annotation models and theoretical frameworks invoke different numbers of instances of these relations and assign the instances different arguments or different scopes, at least on the surface.
			In this paper we develop a method of comparing the scopes of relations in different types of structures by developing a notion of interpretation shared between different structures.
			This interpretation specifies the set of possible scopes of relations compatible with a given structure.
			This theoretical work is important for furthering empirical research on discourse.
			Discourse annotations are expensive.
			It behooves researchers to use as much data as they can, annotated in several formalisms, while pursuing prediction or evaluation in their chosen theory.
			This paper provides a theoretical basis to do this.
			What a given structure expresses exactly is often not clear; some discourse theories are not completely formalized or lack a worked out semantics.
			Nevertheless, in all of them rhetorical relations have semantic consequences bearing on tasks like text summarization, textual entailment, anaphora resolution, as well as the temporal, spatial and thematic organization of a text Hobbs, Stickel, and Martin 1993; Kehler 2002; Asher 1993; Lascarides and Asher 1993; Hobbs, Stickel, and Martin 1993; Hitzeman, Moens, and Grover 1995, inter alia.
			Theories like SDRT or Polanyi et al. 2004 adopt a conception of discourse structure as logical form.
			Discourse structures are like logical formulae and relations 1 The Penn Discourse Treebank Prasad et al. 2008 could also be considered as a corpus with partial dependency structures.
			2 Proceedings of the SIGDIAL 2013 Conference, pages 2–11, Metz, France, 2224 August 2013.
			Qc 2013 Association for Computational Linguistics function like logical operators on the meaning of their arguments.
			Hence their exact scope has great semantic impact on the phenomena we have mentioned, in exactly the way the relative scope of quantifiers make a great semantic difference in first order logic.
			By concentrating on exact meaning representations, however, the syntax-semantics interface becomes quite complex: as happens with quantifiers at the intra sentential level, discourse relations might semantically require a scope that is, at least a priori, not determined by syntactic considerations alone and violates surface order (see s2 ).
			Other theories like Polanyi’s Linguistic Discourse Model (LDM) of Polanyi 1985; Polanyi and Scha 1984, and DLTAG Webber et al. 1999 explicitly adopt a syntactic point of view, and RST with strongly constrained (tree-shaped) structures is subject to parsing approaches duVerle and Prendinger 2009; Sagae 2009; Subba and Di Eugenio 2009 that adhere to the syntactic approach in adopting decoding strategies of syntactic parsing.
			In such theories, discourse structure representations, subject to syntactic constraints (e.g. dominance of spans of text one over another) respect surface order but do not always and unproblematically yield a semantic interpretation that fits intuitions.
			According to Marcu 1996, an RST tree is not by itself sufficient to generate desired predictions; he employs the nuclearity principle, NP, as an additional interpretation principle on scopes of relations.
			We focus on two theories: RST, which offers the model for the annotations of the RST treebank Carlson, Marcu, and Okurowski 2002 and the Potsdam commentary corpus Stede 2004, and on SDRT, which counts several small corpora annotated with semantic scopes, Discor Baldridge, Asher, and Hunter 2007 and Annodis Afantenos et al. 2012.
			We describe these theories in section 2.
			We will also compare these two theories to dependency tree representations of discourse Muller et al. 2012.
			Section 3 introduces a language for describing semantics scopes of relations that is powerful enough to: i) compare the expressiveness (in terms of what different scopes can be expressed) of the different formalisms considered; ii) give a formal target language that will provide comparable interpretations of the different structures at stake.
			Section 4 discusses Marcu’s nuclearity principle and proposes an alternative way to interpret an RST tree as a set of different possible scopes expressed in our language.
			Section 5 provides intertranslability results between the different formalisms.
			Section 6 defines a measure of similarity over discourse structures in different formalisms.
	
	
			These formalisms we introduce here all require the input text to be segmented into elementary units (EDUs).
			The definition of what an EDU is varies slightly with the formalism, but roughly corresponds to the clause level in RST, SDRT and other theories.
			We assume a segmentation common to the different formalisms and use examples with a non controversial and intuitive segmentation.
			Rhetorical Structure Theory (RST), the theory underlying the RSTTreebank is the most used corpus for discourse parsing, cf.
			duVerle and Prendinger 2009, Subba and Di Eugenio 2009, inter alia.
			In its Mann and Thompson 1987 formulation, RST builds a descriptive tree for the discourse by the recursive application of schemata in a bottom-up procedure.
			Each schema application ideally reflects the most plausible relation the writer intended between two contiguous spans of text, as well as hierarchical information about the arguments of the relation, distinguishing between nuclei as essential arguments of a relation and satellites as more contingent parts.
			The set of RS Trees is inductively defined as follows: 1- An EDU is a RS Tree.
			2- if R is a nucleus-statellite relation symbol, s1 and s2 are both RS Trees with contiguous spans (the leftmost leaf in s2 is textually located right after the right most one in s1 ), and (a1 , a2 ) ∈ {(N, S ); (S , N)} then R(t1 a1 , t2 a2 ) is an RS Tree.
			3- if R is a multinuclear relation symbol and (s1 , . . .
			, sn ) are n RS Trees with contiguous spans then R(s1 N, . . .
			, sn N) is an RS Tree.
			Following Mann and Thompson 1987 a complete RS tree makes explicit the content the author intended to communicate.
			RS Trees are graphically represented Marcu 1996 with intermediate nodes labelled with relation names, leaves with symbols referring to EDUs, and edges with nucleus/satellite distinctions.
			Segmented Discourse Representation Theory (SDRT), our second case-study theory, inherits a framework from dynamic semantics and enriches it with rhetorical relations.
			The set of SDRSs is inductively defined as follows: Assume a set of rhetorical relations R, distinguished between coordinating and subordinating relations.
			- Any EDU is an SDRS.
			- Any Complex Discourse Unit (CDU) is a SDRS.
			- a CDU is an acyclic labelled graph (A, E) where every node is a discourse unit (DU) or SDRS and each labelled edge is a discourse relation such that: (i) every node is connected to some other node; (ii) no two nodes are linked by subordinating and coordinating relations, (iii) given EDUs a1 , . . .
			, an+1 in their textual order that yield a CDU (A, E) = G, each EDU a j+1 j < n is linked either: (a) to nodes on the right frontier of the CDU G∗ a subgraph of G constructed from a1 , . . .
			, a j ; or (b) to one or more nodes in Gt = (At , Gt ), a subgraph of G, which linked to one or more nodes on the right frontier of the graph G∗, and where Gt is constructed from a subset of a j+2 , . . .
			an . The right frontier of a graph G consists of the nodes a that are not the left arguments to any coordinating relation and for which if any node b is linked to some node dominating a, then there is a path of subordinating relations from b to a. A Segmented Discourse Representation Structure (SDRS), is assigned a recursively computed meaning in terms of context-change potential (relation betweenpairs of ( world, assignation function )) in the tradi tion of dynamic semantics.
			The semantics of a complex constituent is compositionally defined from the semantics of rhetorical relations and the interpretation of its subconstituents.
			In the base case of an EDU, the semantics is given in dynamic semantics.
			We also consider dependency trees (DTs).
			Muller et al. 2012 derive DTs from the SDRSs of the ANNODIS corpus to get a reduced search space, simplifying automated discourse parsing.
			A DT is an SDRS in which there are no CDUs and there is a unique arc between any two nodes.
			Muller et al. 2012 provide a procedure from SDRSs to DTs, which we slightly modify to respect the Frontier Contraint that they use.
			ζ works in a bottom-up fashion replacing every CDU X that is an argument of a rhetorical relation in γ by their topmost immediate sub-constituent which do not appear on the right of any relation in X, or distributing the top relation when necessary to preserve projectivity.
			To give a simple example: ζ(R([Rt (a, [Rtt (b, c)])], d)) = ζ(R([Rt (a, b) ∧ Rtt (b, c)], d)) = R(a, d) ∧ Rt (a, b) ∧ Rtt (b, c).
			(1) provides a more complicated example we discuss in Section 6).
	
	
			We provide here a language expressive and general enough to express the structures of the 3 theories.
			All our case-study theories involve structures described by a list of rhetorical relations and their arguments.
			Two things may vary: first, the nature of the arguments.
			SDRT for instance, introduces complex constituents ( π : Rsubord (b, c) less, such RST structures are expressible in our framework, if we assume certain semantic equivalences.
			RST allows for two cases of non-binary trees: (i) nucleus with n satellites, each one linked to the nucleus by some relation Rn . Such a structure is semantically equivalent to the conjunction of n-binary relations Rn between the nucleus and the nth satellite, which is expressible in our framework.
			(ii) RST also allows for nary multinuclear relations such as List and Sequence.
			In our understanding, multinuclear relations R(a1 , . . .
			an ), essentially serve a purpose of expressiveness, and such an nary tree is an equivalent to the split non-tree shaped structure R(a1 , a2 ) ∧ R(a2 , a3 ) . . .
			R(a(n−1) , an ).
			This seems clear for the Sequence relation, which states that a1 . . .
			an are in temporal sequence and can be equivalently formulated as “each ai precedes ai+1 ”.
			This might appear less obvious for the List relation.
			The semantics (as it appears on the RST website http: //www.sfu.ca/rst/) of this relation requires the ai to be ”comparable”, and as far as this is a transitive property, we can split the relation into a set of binary ones.
			Formally, our scope language Lsco pes is a fragment of that of monadic second order logic with two sorts of individuals: relation instances (i), and elementary consti tuants (l).
			Below, we assume R is the set of all relation names (elaboration, narration, justification, . . .
			Definition 1 (Scoping language).
			Let S be the set {i, l}.
			The set of primitive, disjoint types of Lsco pes consists of i, l and t (type of formulae).
			For each of the types in S , we have a countable set of variable symbols Vi (Vl ).
			Two additional countable sets of variable symbols V(i,t) and V(l,t) range over sets of individuals.
			These four sets of variable symbols are pairwise disjoint.
			The alphabet of our language is constituted by Vi , Vs , a set of predicates, equality, connector and quantifier symbols.
			The set of predicate symbols is as follows: as arguments of relations (e.g. Rsubord (a, π) ), 1) For each relation symbol r in R, LR is a unary which finds a counterpart within RS Trees, where a relation may directly appear as argument of another (R(aN , R(bN , cS )S )) but not within dependency trees.
			Second, the set of constraints that restrict the possible lists of such relations can vary across theories (e.g. right frontier, or requirement for a tree structure).
			To deal with the first point above, we remark that it suffices to list, for each instance of a discourse relation, the set of elementary constituents that belong to its left and right scope in order to express the three kinds of structures.
			We do this in a way that an isomorphic structure can always be recovered.
			Models of our common language will be a list of relation instances and elementary constituents, together with a set of predicates stating what is in the scope of what.
			As for the second point, we axiomatize each constraint in our common language, thereby describing each of the 3 types of discourse structures as a theory in our language.
			Our language contains only binary relations.
			Among discourse formalisms, only RST makes serious (andempirical) use of n−ary discourse relations.
			Neverthe predicate of type (i, t)—i.e., LR : (i, t) . 2) unary predicates, sub, coord and sub−1 : (i, t).
			3) binary predicates ∈l and ∈r : (i, l, t).
			4) two equality relations, =s : (s, s, t) for s ∈ {i, l}.
			Logical connectors, and quantifiers are as usual.
			The sets of terms Γi , Γl and Γt are recursively defined: 1.
			Vi ⊆ Γi , V arl ⊆ Γl . 2.
			For v ∈ Vs,t , v : (s, t).
			3.
			For.
			each symbol σ of type (u1 , . . .
			, un ) in the alphabet, for all (t1 , . . .
			, tn−1 ) ∈ Γu1 × · · · × Γun−1 , σ[t1 , . . .
			, tn−1 ] ∈ Γun .Γt is the set of well formed formulae of the scope lan guage.
			The predicates ∈l and ∈r take a relation instance r oftype i and a elementary constituent x of type l as argu ments.
			Intuitively, they mean that x has to be included in the left (for ∈l ) or right (for ∈r ) scope of r. For each relation symbol R such as justification or elaboration, the predicate LR takes a relation instance r has argument and states that r is an instance of the rhetorical relation R. Predicates sub, coord and sub−1 apply to a re lation instance r, respectively specifying that r’s left argument hierarchically dominate its right argument, that both are of equal hierarchical importance, or that the left one is subordinate to the right one.
			Definition 2 (Scope structure and Interpretation).
			A scope structure is an Lsco pes -structure M = (Di , Dl , |.|M ).
			Di and Dl are disjoint sets of individuals for the sorts i and l respectively, and |.|M assigns to each predicate symbol P of type (u1 , . . .
			, un , t) a func R1 (t1 , t2 ), R2 (t2 , t3 ), . . .
			, proceed to recursively compute the scope-structures Mi for each of the relations using 2 (take care to introduce a ’fresh’ relation instance individual for each relation of the sequence), then return the union of the models Mi . RST Decoding Given a finite scope structure M = (Di , Dl , |.|M ), for each relation instance r compute the tion |.|P : Du ×· · ·× Du �→ {0, 1}.
			Variables of type (i, t) left arguments of r and its right arguments.
			We then are assigned subsets of Di and similarly for variables of type (l, t), The predicates =i and =s are interpreted as equality over Di and Dl respectively.
			The interpretation [·]M of a formula φ ∈ ΦS is thestandard interpretation of a monadic second order for mula w.r.t to a model and a valuation (interpretation of first order quantifiers and connectors is as usual, quantification over sets is over all sets of individuals).
			Va lidity |= also follows the standard definition.
			These scope structures offer a common framework for different discourse formalisms.
			Given one of the three formalisms, we say that two structures S 1 and S 2 are equivalent iff there is an encoding from one structure into a scoped structure or set of scoped structures and a decoding back from the scoped structure or set of scoped structures into S 2 Fact 1.
			One can define two algorithms I and E such that: • from a given structure s which is a RS Tree, a SDRS or a DT, I computes a scope structure I(s).
			• given such a computed structure, E allow to retrieve the original structure s (E(I(s)) = s).
			RST Encoding and Decoding To flesh out I and E for RST, we need to define dominance.
			Set lArgs(r) = identify L(r), the unique relation symbol R such that r ∈ |LR |M . If that fails, the algorithm fails.
			Similarly retrieve the right nuclearity schema from the adequate predicate that applies to r. Then compute the dominance relations for r. If the input structure M = I(t) for some RS Tree t then there is at least one maximal relation instance for the dominance relation.
			If t the root node of t is a binary relation, there is exactly one maximal element in the dominance relation.
			If there is none, then we return fail.
			If there is exactly one, recursively compute the two RS Trees obtained from the models computed from the left and right arguments and descendants of r. If there is more than one, the root node of the encoded RS Tree was a nary relation and one has to reconstruct the nary node if that is possible; if not the algorithm fails (but that means the input structure was not obtained from a valid RS Tree).
			SDRT Encoding and Decoding: This is similar to the RST encoding and decoding; for the encoding algorithm, we proceed recursively top down.
			A SDRS s is a complex constituent that contents a graph g =(V, E) whose edges are relations holding between sub constituents, simple or complex as well.
			First come up with an encoding of the set E of all edges that hold between two sub-constituents of s, i.e. a struc ture M = (Di = Ei , Dl = V, {LR }, ∈l , ∈r ), where, for {e ∈ Dl | (r, e) ∈ |∈l |M }; rArgs(r) is defined analogously each edge e E , L encodes its relation type, and (where ∈r replaces ∈l ).
			The left and right dominance 1 ∈ i R 1 relations kl and kr are defined as follows: r kl rt iff ∈l and ∈r consists of all the pairs (x, e) of left and (Args(r) ⊆ lArgs(rt )).
			- r kl rt ↔ ∀z : l((z ∈l r) ∨ z ∈r r)) → z ∈l rt ) with r kr rt defined analogously.
			Dominance k is: k=kl ∪ kr . - lArgs(r, X) ↔ ∀z : l(z ∈l r) ↔ z ∈ X), with rArgs(r, X) similar and -Args(r, X) ↔ ∀z : l((z ∈l r) ∨ z ∈r r)) ↔ z ∈ X).The NS, NN and NS schemes of RST will be re spectively encoded by the predicates sub, coord and sub−1 . We proceed recursively.
			If t is an EDU e, return Mt = (Di = ∅, Dl = {e}, E) where E is the inter pretation that assigns the empty set to each predicate symbol.
			If the root of t is a binary node instantiating a relation R(t1 a , t2 a ), let Tr ∈ {sub, coord, sub−1 } be the predicate that encodes the schema a1 a2 , let Mt1 = right nodes x of the edges e ∈ E. Finally, for each complex immediate sub-constituent of s in Dl , update M as follows: for c such a subconsituent, recursively compute its encoding Mc , then add everything of Mc to M, finally remove c from M but add instead for each relation r scoping over c to the right (left), all the pairs {(r, x) | x is a constituent in Mc }.
			The decod ing works again similarly to the one for RST, top-down once again: one recursively retrieves immediate content of the current complex constituent at each level then moves to inner constituents.
			DT: Dependency trees are syntactically a special case of SDRSs; there is only one CDU whose domain is only EDUs.
			The scope language allows us to axiomatize three 1 2 2 2 (D1 , D1 , |.| ) and Mt = (D , D , |.| ).
			The algorithm re classes of scope structures corresponding to RS Trees, i l 2 i l turns Mt = (D1 ∪ D2 ∪ {r}, D1 ∪ D2 , |.|Mt ) where r is a SDRSs and DTs.
			Not every scope structure will yield i i l l ’fresh’ relation instance variable not in D1 or D2 , and a RS Tree when fed to the RST decoding algorithm, i i |.|Mt is updated in the appropriate fashion to reflect the left and right arguments of r. Finally, if the root of t is an nary node, split it into a sequence of binary relation only those obtainable from encoding an RS tree.
			As not all scope structures obey these axioms, our language is strictly more expressive than any of these discourse for- malisms.
			As an example of an axiom, the following formula expresses that a relation cannot have both left and right scope over the same elementary constituent: Strong Irreflexivity: ∀r : i∀x : l (x ∈l r ∧ x ∈r r)) (A0 ) Strong irreflexivity entails irreflexivity; a given relation instance cannot have the same (complete) left and right scopes.
			All discourse theories validate A0 . In the Appendix, we define left and right strong dominance relations kl(r) as well as nary RS trees and CDUs of SDRT.
			We exploit these facts in the Appendix to express axioms (A1A9) that axiomatize the structures corresponding to RST, SDRT and DTs.
			Axiom A1 says that every discourse unit is linked via some discourse relation instance.
			Axiom A2 insures that all our relation instances have the right number of arguments; Axioms A3 and A4 ensure acyclicity and no crossing dependencies.
			A5 a and A5 b restrict structures to a tree- like dominance relation with a maximal dominating element, while A6 defines the Right Frontier constraint for SDRT, and A7 fixes the domain for SDRT constraints on CDUs.
			A8 ensures that no coordinating and subordinating relations have the same left and right arguments, while A9 provide the restrictions needed to define the set of DTs.
			We use the encoding and decoding maps to show: Fact 2.
			1. The theory TRS T ={A0 , A1 , A2 , A3 , A4 , A5 a, A5 b, A8 }.
			characterizes RST structures in the sense that: - E applied to any structure M such that M |= TRS T yield an RST Tree.
			- for any RST Tree t, I(t) |= TRS T . 2.
			The theory TS DRT ={A0 , A1 , A2 , A3 , A6 , A7 , A8 }.
			similarly characterizes SDRSs.
			3.
			The theory TDT =TS DRT ∪ {A9 a, A9 b} similarly.
			characterizes Dependency Trees structures.
	
	
			The previous section defined the set of scope structures as well as the means to import, and then retrieve, RS trees, DTs, or SDRs into, and from, this set.
			Some of these scope structures export both into RST and SDRT, yielding a 1 − 1 correspondence between a subset ofSDRT and RST structures.
			But what does this corre spondence actually tell us about these two structures?
			In mathematics, the existence of an isomorphism relies on a bijection that preserves structure.
			Our correspondence preserves the immediate interpretation of the semantic scopes of relations.
			Immediate Interpretation Consider a scope structure M (validating A0 , A1 , A2 ).
			The predicates lArgs(r) and rArgs(r) are the sets of all units in the left or right scope of a relation instance r. Whether r, labelled by relation name R holds of two discourse units or not in M, depends on the semantic content of its left and right arguments, recursively described by lArgs(r) and all relations rt such that rt cl r, and rArgs(r) and all relations rt such that rt cr r. Algorithm I computes what we call the immediate interpretation of an input structure.
			Intuitively, in this interpretation the semantic scope of relations is directly read from the structures themselves; a node R(t1 , t2 ) in a RS Tree expresses that R holds between contents expressed by the whole substructures t1 and t2 . Similarly, for SDRT and DTs, im mediate interpretation of an edge π1 →R π2 is that R holds between the whole content of π1 and π2 . While this immediate interpretation is standard in SDRT, it is not in RST.
			Consider again (1) from the introduction or: (2) [In 1988, Kidder eked out a $ 46 million profit,]31 [mainly because of severe cost cutting.]32 [Its 1,400-member brokerage operation reported an estimated $ 5 million loss last year,]33 [although Kidder expects to turn a profit this year]34 (RST Treebank, wsj 0604).
			(3) [Suzanne Sequin passed away Saturday at the communal hospital of Bar-le-Duc,]3 [where she had been admitted a month ago.]4 [.
			] [Her funeral will be held today at 10h30 at the church of Saint-Etienne of Bar-le-Duc.]5 (annodis corpus).
			These examples involve what are called long distance attachments.
			(2) involves a relation of contrast, or comparison between 31 and 33, but which does not involve the contribution of 32 (the costs cutting of 1988).
			(3) displays something comparable.
			A causal relation like result, or at least a temporal narration holds between 3 and 5, but it should not scope over 4 if one does not wish to make Sequin’s admission to the hospital a month ago a consequence of her death last Saturday.
			Finally in (1) C4 elaborates on C1 , but not on the fact that C1 is attributed to chief Garcia, so the corresponding elaboration relation should not scope over C3 . It is impossible however, to account for long distance attachment using the immediate interpretation of RST trees.
			(2), for instance, also involves an explanation relation between 31 and 32, which should include none of 33 or 34 in its scope.
			Since 31 is in the scope of both the explanation and the contrast relation, Axiom A5 a of the previous section entails than an RST tree involving the two relations has to make one of the two relations dominates the other.
			Marcu’s Nuclearity Principle (NP) Marcu 1996 provides an alternative to the immediate interpretation and captures some long distance attachments Danlos 2008; Egg and Redeker 2010.
			According to the NP, a rela tion between two spans of text, expressed at a node of a RS Tree should hold between the most salient parts of these spans.
			Most salient part is recursively defined: the most salient part of an elementary constituent is itself, for a multinuclear relation R(t1 N , . . .
			, tk N ) its most salient part is the union of the most salient parts of the attribution N reason S 1 S 5 N S 3 restatement N 2 ti 2 . Following Egg and Redeker 2010, the NP, or weak NP is a constraint on which RST trees may correctly characterize an input text; it is not a mechanism for computing scopes.
			Given their analysis of (1) given in the introduction, NP entails that Elab1 holds between C1 and C4 , accounting for the long distance attachment, and that Attribution holds between C1 and C4 which meets intuition in this case.
			There is however no requirement that Attribution do not hold between the wider span [C1 , C2 ] and C3 , as there is no requirement that Elab1 does not hold between [C1 , C2 , C3 ] and C4 . In order to accurately account for (1), the former must be true and the latter false.
			However, this interpretation of NP together with an RST tree does not determine the semantic scope of all relations.
			Danlos 2008 reformulates NP as a Mixed Nuclearity Principle (MNP) that outputs determinate scopes for a given structure.
			The MNP requires for a given node, that the most salient parts of his daughters furnish the exact semantic scope for the relation at that node.
			The MNP transforms an RST tree t into a scope structure Mt , which validates A0 − A3 but also A6 .3 , A7 and A8 . Hence M could be exported back to SDRT and the MNP would yield a translation from RST-trees to SDRSs.
			But when applied to the RST Treebank, the MNP yields wrong, or at least incomplete, semantic scopes for intuitively correct RS Trees.
			The mixed principle applied to the tree of s1 gives the Attribution scope over C1 only, but not C2 , which is incorrect.
			Focusing on the attribution relation which is the second most frequent in the RST Treebank, we find out that, regardless of whether we assign Attribution’s arguments S and N or N and S, this principle makes wrong predictions 86% of the time in a random sampling of 50 cases in which we have attributions with multi-clause second argument spans.
			Consider the following example from the RST Treebank: (4) [Interprovincial Pipe Line Co. said]1 [it will delay a proposed two-step, 830 million Canadian- dollar [(US$705.6 million)]3 expansion of its system]2 [because Canada’s output of crude oil is shrinking.]4Applied to the annotated RS Tree for this example (fig 2 Except for Sequence which only retains the most salient part of tk 3 That A6 is valid in the resulting model is not immediate.
			Assume a multinuclear (coordinating) relation instance r has scope over xn and xn+k later in the textual order.
			Then it is impossible to attach with rt a later found constituent xn+k+l to xn alone, for it would require that xn+1 escapes the scope of rt from the MNP which it will not do by multinuclearity of r. Figure 1: Annotated RST Tree for example (4).
			ure 1), the MNP yields an incorrect scope of the attribution relation over 2 only, regardless of whether the attribution is annotated N-S or S -N.
			The idea behind the weak NP provides a better fit with intuitions.
			The principle gives minimal semantic requirements for scoping relations; everything beyond those requirements is left underspecified.
			We formalize this as the relaxed Nu- clearity Principle (RNP), which does not compute one structure where each relation is given its exact scope, but a set of such structures.
			The target structures are not trees any more, but we want them to still reflect the dominance information present in the RS Tree.
			We therefore define a notion of weak dominance over structures of the scoping lan guage: for two sets of constituents, X ::S Y iff X ⊆ Y or there is a subordinating relation whose left argument is X and right one Y . Weak dominance is given by transitive closure ::S∗ of ::S. For two relations, r ::S∗ rt iff the left argument of r weakly dominates both arguments of rt . ::S∗ is symmetrically defined.
			Finally, structures computed by the RNP have to validate the weakened version of A5 : if two relations scope over the same elementary constituent one has to weakly dominates the other.
			Let AW denote this axiom.
			Definition 3 (Relaxed Nuclearity Principle).
			One can assign to an RS Tree t a formula of the scoping lan guage φt = ∃x¯∃r¯ψt ∪ Γt such that: 1– ψt is a formula specifying that all individuals quantified in x¯ and r¯ are pairwise distinct, and that there is no other individuals that the ones just mentioned.
			ψt also specifies for each intermediate node n that the corresponding relation instance rn is labelled with the adequate relation symbol R and relation type (subordinating if N-S . . .
			2– Γt encodes the nuclearity principle applied to t: for all intermediate nodes ni and n j in t such that nl is the left (resp.
			right) daughter of ni , Γt specifies that ni must scope to the left (resp.
			right) over the nucleus of n j . The interpretation [t] is defined as the set of structures M that validate φt and A0 , A1 , A2 , A3 , AW (they all have |t| individuals, as fixed by ψt ).
			Moreover, it can be shown that each model of this set validates TS DRT ; so we have a interpretation of an RS-Tree into a set of SDRSs.
	
	
			DTs are a restriction of SDRSs to structures without complex constituents.
			So the ζ function of section 2 can transform distinct SDRSs transform into the same who states that whenever a sequence of coordinating DT with a consequent loss of information.
			relation Ri originates as a node which appear to be a →R1 π π : b →R2 c | a →R1 b →R2 π →R2 b | 1 (1) also in the right scope of a subordinating relation Rs , Rs must totally include all the Rc in its right scope.
			A second principle is required, who states that whenever two subordinating relations R0s and Rt originate at the Each of the SDRSs above yields the same DT after simplification, namely the second one a →R1 b →R2 c. The natural interpretation of a DT g describes the set of fully scoped SDRS structures that are compatible with these minimal requirements, i.e that would yield g by simplification.
			To get this set, every edge r(x, y) in g, r, must be assigned left scope among the descendants of x in g (and right scope among those of y); this is a consequence of i) x and y being heads of the left and right arguments of r and ii) the SDRSs that are compatible with g do not admit relations with a right argument in one constituent and a left one outside of it.
			Definition 4.
			Assume that we map each node4 x of g into a unique variable vx ∈ Vl and each edge e into a unique variable symbol re ∈ Vi . Define x¯ and r¯ in an analogous way as in definition 3.For a given dependency tree g, we compute a for s same node in the DT, and the right argument of Rt is located after the right argument of Rs , any structure in the interpretation of the DT must verify Rt ::Sl Rs . The translation needs these requirements to work, because: i) with the NP a relation scoping over a multinuclear one must includes all the nucleus in RST, and ii)a node in a RS Tree cannot scope over something that is not its descendant).
			Let CDP+ denote these requirements.
			Using the restricted interpretation of a DT g; [g]C DP = {M | M |= A0A3 , A6 , A7 , CDP+ }, we transform an RS Tree t into a dependency graph G(t) such that [t] = [G(t)]C DP : Definition 5 (RS Trees to dependency graphs).
			The translation G takes a RS Tree t as input and outputs a pair (G, n), where G = (Nodes, Edges) is the corre sponding dependency graph, and n an attachment point used along the recursive definition of G. mula φg = ∃x¯∃r¯ ψg ∪ Γg such that If t is an EDU x then (G)(t) = (({x}, {}), x).• ψg is defined analogously as in definition 3, defin ing the set of relation instances and EDUs.
			• Γg is the formula stating the minimal scopes for each relation instance: for all edge in e = R(x, y) in g, Γg entails i) re has vx in its left scope and vy in its right scope and ii) let Des(x) be the set of variable symbols for all the descendants of x in g, Γg entails that if re has left scope over some vz then vz is in Des(x) (symmetrically for y and right scope).
			The interpretation [g] of a DT is: {M | M |=φg , A0A3 , A6 , A7 }.
			The DT a →R1 b →R2 c for instance, is interpreted as a set of three structures iso morphic to the ones in (1) above.
			We now relate DTs to RS Trees interpreted with the RNP.
			To this aim, we focus on a restricted class of DTs, those who involve i) coordinating chains of 3 edus or more only if they involve a single coordinating relation: x1 →R1 x2 →R2 · · · →Rn−1 xn may appear only for n > 2 if all the Ri are the same coordinating relation, and ii) subordinating nests of 3 edus or more only if they involve a single subordinating relation: • • If t = R(t1 N , t2 S ) then let (G1 , n1 ) = G(t1 ) and (G2 , n2 ) = G(t2 ).
			G(t) = ((G1 ∪ G2 ∪ {Rsubord (n1 , n2 ))}; n1 ) • If t = R(t1 S , t2 N ) then G(t) = G(R(t2 N , t1 S )) • If t = R(t1 N , . . .
			, tk N ) (multinuclear), let (Gi , ni ) = G(ti ), let G be the result of adding a chain n1 →Rcoord · · · →Rcoord nk to the union of the Gi , G(t) = (G; n1 ) • If t is a nuclear satellite relation with several satellites R(t1 S , . . .
			t j N , . . .
			tk S ), compute the Gi has in the previous case, then add to the union of the Gi the nest of k − 1 subordinating relations R linking n j to each of the ni , i =f: j. Recall RS Tree (s1 ).
			Applying G to this tree yields the dependency tree (s3 ): Elab1 (C1 , C2 )∧Attr(C1 , C3 )∧ Elab2 (C1 , C4 ).
			[s3 ] supports any reading of (s1 ) provided by RNP, but also an additional one where Attr scopes over [C1 , C2 , C4 ].
			This is however forbidden x R1 Rn is allowed for n > 1 only if all Ri are labelled with the same subor by CDP+ for C4 is after C3 in the textual order but Elab(C1 , C4 ) Jl Attr(C1 , C3 ).
			y1 . . .
			yn dinating relation.
			This restricted class of DTs corresponds exactly with the set of RS-Trees interpreted with the RNP, provided that we restrict the interpretation of a DT in the following way: a principle called Continuing Discourse Pattern, CDP Asher and Lascarides 2003 must apply, 4 Recall that unlike RS Trees, DTs have EDUs as nodes and relations as edges.
	
	
			The framework we have presented yields a notion of similarity that applies to structures of different for- malisms.
			To motivate our idea, recall example (1); the structure in (s3 ) in which Attribution just scopes over C1 differs from the intuitively correct interpretation only in that Attribution should also scope over C2 as in (s2 ), while a structure that does this but in which C3 is in the scope of the Elaboration relation is intuitively further away from the correct interpretation.
			Our similarity measure Sim over structures M1 and M2 assumes a common set of elementary constituents and a correspondence between relation types in the structures.
			We measure similarity in terms of the scopes given to the relations.
			The intuition, is that givena map f from elements of relation instances in M1 re lation instances in M2 , we achieve a similarity score by counting for each relation instance r the number of EDUs that are both in the left scope of one element of r and in f (r), then divide this number by the total number of diffrents constituents in the left scope of r1 and r2 , and do the same for right scopes as well.
			The global similarity is given by the correspondence which yields the best score.
			Given a relation r1 ∈ M1 and a relation r2 ∈M2 , let ( 1 if r1 and r2 have the same label C1 and C2 are left argument of Attr (though not C4 ).
			With MNP, the similarity is 17/36.
			Given our results in sections 4 and 5, we have: Fact 3.
			(i) For any DT g without a > 3 length flat sequence and interpreted using CDP+, there an RS tree t interpreted with RNP such that S im(g, t) = 1.
			(ii) For any RS tree with RNP there is a DT g such that S im(t, g) = 1.
			To prove (i) construct a model using Definition 4 and then use RST decoding.
			To prove (ii) construct a model given Definition 3 and use DT encoding.
			Our similarity measure provides general results for SDRSs and DTTs (and a fortiori SDRSs and RS trees) (See Appendix).
	
	
			Our work shares a motivation with Blackburn, Gardent, and Meyer-Viol 1993: Blackburn, Gardent, and Meyer- Viol 1993 provides a modal logic framework for for δ(r1 , r2 ) =0 otherwise . De malizing syntactic structures; we have used MSO and fine Cl (r1 , r2 ) = |{x : l | M1 |= x ∈l r1 ∧ M2 |= x ∈l r2 }|, the number of constituents over which r1 and r2 scope and Dl (r1 , r2 ) = |{x : l | M1 |= x ∈l r1 ∨ M2 |= x ∈l r2 }|.
			Define Cr and Dr analogously and assume that M1 has less relation instances than M2 . Let Inj(D1 , D2 ) be the our scope language to formalize discourse structures.
			While many concepts of discourse structure admit of a modal formalization, the fact that discourse relations can have scope over multiple elementary nodes eitheri i in their first or second argument makes an MSO treat set of injections of relations instances of M1 to those of M2 . 1 S im(M1 , M2 ) = 2Max(|M |, |M |) × ment more natural.
			Danlos 2008 compares RST, SDRT and Directed Acyclic Graphs (DAGs) in terms of their strong generative capacity in a study of structures and examples involving 3 EDUS.
			We do not consider generative capacity, but we have given a generic and gen 1 2 eral axiomatization of RST, SDRT and DT in a formal Max δ(r, f (r)) × ( Cl (r, f (r)) + Cr (r, f (r)) ) interpreted language.
			We can translate any structure of f ∈Inj(D1 ,D2 ) r:i Dl (r, f (r)) Dr (r, f (r)) i i these theories into this language, independent of their If M2 has more relation instances, Invert arguments and use the definition above.
			If they have same number of instances, both directions coincide.
			d(M1 , M2 ) = 1 − S im(M1 , M2 ) For a discourse structure M, S im(M, M) = 1; Simranges between 1 and 0.
			d is a Jaccard-like met ric obeying symmetry, d(x, x) = 0 d(x, y) =f: 0 for x =f: y, and the triangle equality.
			One can further define the maximal or average similarity between any pair of structures of two sets S 1 and S 2 . This gives an idea of the similarity between two underspecified interpretations, such as the ones provided by RNP of section 4.
			For example, the maximal similarity between (s2 ) interpreted as itself (immediate interpretation) and a possible scope structure for the DT (s3 ), interpreted with the underspecified [] of section 5, is 7/12.
			It is provided by the interpretation of (s3 ) where Attr is given left scope over C1 , C2 , C4 , Elab1 holds between C1 and C2 , and the second Elab fails to match the continuation of (s3 ).
			sim([s2 ], [ζ(s2 ]) = 7/12 also, because ζ must distribute [2, 4] in s2 to avoid crossing dependencies; so [ζ(s2 )] - [s3 ].
			The maximal similarity between the RS tree in (s1 ) with RNP (or equivalently, (3) with []C DP+ ) and (s2 ) is 19/36, achieved when both linguistic realization.
			We agree with Danlos that the NP does not yield an accurate semantic representation of some discourses.
			We agree with Egg and Redeker 2010 that the NP is rather a constraint on structures, and we formalize this with the relaxed principle and show how it furnishes a translation from RS trees to sets of scoped structures.
			Danlos’s interesting correspondence between restricted sets of RST trees, SDRSs and DAGs assumes an already fixed scope-interpretation for each kind of structure: SDRSs and DAGs are naturally interpreted as themselves, and RS Trees are interpreted with the mixed NP Our formalism allows us both to describe the structures themselves and various ways of computing alternate scopes for relations.
			With regard to the discussion in Egg and Redeker 2008; Wolf and Gibson 2005 of tree vs. graph structures, we show exactly how tree based structures like RST with or without the NP compare to graph based formalisms like SDRT.
			We have not investigated Graphbank here, but the scope language can axiomatize Graphbank (with A0A3 , A8 ).
	
	
			We have investigated how to determine the semantic scopes of discourse relations in various formalisms by developing a canonical formalism that encodes scopes of relations regardless of particular assumptions about discourse structure.
			This provides a lingua franca for comparing discourse formalisms and a way to measure similarity between structures, which can help to compare different annotations of a same text.
	
